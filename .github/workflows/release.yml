name: Release and Deploy

# Permissions needed for tag creation and repository access
permissions:
  contents: write  # Needed to create tags and push to repository
  pull-requests: write  # Needed to comment on PRs
  issues: write  # Needed to comment on issues

on:
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      deployment_type:
        description: "Type of deployment"
        required: true
        type: choice
        default: "manual_tag_deploy"
        options:
          - "manual_tag_deploy"
          - "create_new_release"
      tag_to_deploy:
        description: "Tag to deploy (e.g., v2.2.3, v2.1.0)"
        required: false
        type: string
        default: "v2.2.3"
      deploy_target:
        description: "Deployment target"
        required: true
        default: "staging"
        type: choice
        options:
          - "staging"
          - "latest"
      release_type:
        description: "Release type (only for new releases)"
        required: false
        default: "none"
        type: choice
        options:
          - none
          - patch
          - minor
          - major

jobs:
  checkout-tag:
    name: Checkout Selected Tag
    runs-on: ubuntu-latest
    if: github.event.inputs.deployment_type == 'manual_tag_deploy'
    outputs:
      ref: ${{ steps.set-ref.outputs.ref }}
      tag: ${{ steps.set-ref.outputs.tag }}
    steps:
      - name: Set checkout reference
        id: set-ref
        run: |
          if [ "${{ github.event.inputs.tag_to_deploy }}" != "" ]; then
            echo "ref=${{ github.event.inputs.tag_to_deploy }}" >> $GITHUB_OUTPUT
            echo "tag=${{ github.event.inputs.tag_to_deploy }}" >> $GITHUB_OUTPUT
            echo "Deploying tag: ${{ github.event.inputs.tag_to_deploy }}"
          else
            echo "ref=${{ github.ref }}" >> $GITHUB_OUTPUT
            echo "tag=current" >> $GITHUB_OUTPUT
            echo "Deploying current ref: ${{ github.ref }}"
          fi

      - name: Checkout repository at tag
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.set-ref.outputs.ref }}

  validate:
    name: Pre-build Validation
    runs-on: ubuntu-latest
    if: always()
    needs: [checkout-tag]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.deployment_type == 'manual_tag_deploy' && github.event.inputs.tag_to_deploy || github.ref }}

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm

      - name: Run linting
        run: pnpm run lint

      - name: Run type checking
        uses: ./.github/actions/typecheck

  e2e-tests:
    name: E2E Tests
    uses: ./.github/workflows/e2e.yml
    needs: validate
    if: github.event.inputs.deployment_type != 'manual_tag_deploy'
    with:
      environment: 'production'
      fail_on_error: false  # Non-blocking: continue pipeline even if e2e tests fail

  build:
    name: Build Project
    runs-on: ubuntu-latest
    needs: [validate]  # Only depend on validate, not e2e-tests (non-blocking)
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.deployment_type == 'manual_tag_deploy' && github.event.inputs.tag_to_deploy || github.ref }}

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm

      - name: Build and verify
        uses: ./.github/actions/build-project
        with:
          deployment-type: 'production'

      - name: Verify build output exists
        run: |
          echo "Checking for build output..."
          if [ -d "out" ]; then
            echo "‚úÖ out/ directory found"
            echo "Contents:"
            ls -la out/ | head -5
            echo "Total files: $(find out -type f | wc -l)"
          else
            echo "‚ùå out/ directory not found!"
            echo "Available directories:"
            ls -la
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: out/
          retention-days: 1

  create-release:
    name: Create Release (if needed)
    runs-on: ubuntu-latest
    needs: build
    if: (github.event_name == 'pull_request' && github.event.pull_request.merged == true) || github.event_name == 'workflow_dispatch'
    outputs:
      new-tag: ${{ steps.release.outputs.new-tag }}
      should-create-release: ${{ steps.check.outputs.should-create-release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if release should be created
        id: check
        run: |
          SHOULD_CREATE="false"
          RELEASE_TYPE="none"

          # Check for release type in workflow input (manual dispatch)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.release_type }}" != "none" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
            SHOULD_CREATE="true"
            echo "Manual release requested: $RELEASE_TYPE"
          # Check for release type in PR title and body (merged PR)
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body }}"
            PR_TEXT="$PR_TITLE $PR_BODY"

            echo "Checking PR for release type..."
            echo "PR Title: $PR_TITLE"

            if echo "$PR_TEXT" | grep -qE "\[(major|minor|patch)\]"; then
              RELEASE_TYPE=$(echo "$PR_TEXT" | grep -oE "\[(major|minor|patch)\]" | head -1 | tr -d '[]')
              SHOULD_CREATE="true"
              echo "Release type found in PR text: $RELEASE_TYPE"
            elif echo "$PR_TEXT" | grep -qE "(#major|#minor|#patch)"; then
              RELEASE_TYPE=$(echo "$PR_TEXT" | grep -oE "#(major|minor|patch)" | head -1 | tr -d '#')
              SHOULD_CREATE="true"
              echo "Release type found in PR text: $RELEASE_TYPE"
            elif echo "$PR_TEXT" | grep -qiE "(major release|minor release|patch release)"; then
              if echo "$PR_TEXT" | grep -qiE "major release"; then
                RELEASE_TYPE="major"
              elif echo "$PR_TEXT" | grep -qiE "minor release"; then
                RELEASE_TYPE="minor"
              elif echo "$PR_TEXT" | grep -qiE "patch release"; then
                RELEASE_TYPE="patch"
              fi
              SHOULD_CREATE="true"
              echo "Release type found in PR text: $RELEASE_TYPE"
            else
              # Default to major release for merged PRs without explicit version type
              RELEASE_TYPE="major"
              SHOULD_CREATE="true"
              echo "No release type specified - defaulting to major release"
            fi
          fi

          echo "should-create-release=$SHOULD_CREATE" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: latest-tag
        if: steps.check.outputs.should-create-release == 'true'
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"

      - name: Calculate next version
        id: next-version
        if: steps.check.outputs.should-create-release == 'true'
        run: |
          LATEST_TAG="${{ steps.latest-tag.outputs.latest-tag }}"
          RELEASE_TYPE="${{ steps.check.outputs.release-type }}"

          # Remove 'v' prefix for calculation
          VERSION=${LATEST_TAG#v}

          # Split version into parts
          IFS='.' read -r -a VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          # Calculate new version based on release type
          case $RELEASE_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "next-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEW_VERSION"

      - name: Create and push tag
        id: release
        if: steps.check.outputs.should-create-release == 'true'
        run: |
          NEW_TAG="${{ steps.next-version.outputs.next-version }}"

          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Create and push tag
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin "$NEW_TAG"

          echo "new-tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Created and pushed tag: $NEW_TAG"

      - name: Create GitHub Release
        if: steps.check.outputs.should-create-release == 'true'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.next-version.outputs.next-version }}
          release_name: Release ${{ steps.next-version.outputs.next-version }}
          body: |
            ## What's Changed

            This release was automatically created from PR merge to main branch.

            **Deployment Info:**
            - üåê Production URL: https://minademian.com/
            - üîó Release URL: https://minademian.com/releases/${{ steps.next-version.outputs.next-version }}/

            **Full Changelog**: https://github.com/${{ github.repository }}/commits/${{ steps.next-version.outputs.next-version }}
          draft: false
          prerelease: false

  configure:
    name: Configure Deployment
    runs-on: ubuntu-latest
    needs: [build, create-release]
    if: always() && needs.build.result == 'success' && (github.event.inputs.deployment_type == 'manual_tag_deploy' || needs.create-release.result == 'success' || needs.create-release.result == 'skipped')
    outputs:
      deployment-type: ${{ steps.config.outputs.deployment-type }}
      target-path: ${{ steps.config.outputs.target-path }}
      deployment-url: ${{ steps.config.outputs.deployment-url }}
      environment-name: ${{ steps.config.outputs.environment-name }}
      git-tag: ${{ steps.config.outputs.git-tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.deployment_type == 'manual_tag_deploy' && github.event.inputs.tag_to_deploy || github.ref }}

      - name: Debug deployment information
        run: |
          echo "üîç Debugging deployment information:"
          echo "Deployment type: ${{ github.event.inputs.deployment_type }}"
          echo "Tag to deploy: ${{ github.event.inputs.tag_to_deploy }}"
          echo "Deploy target: ${{ github.event.inputs.deploy_target }}"
          echo "Create-release job result: ${{ needs.create-release.result }}"
          if [ "${{ needs.create-release.outputs.new-tag }}" != "" ]; then
            echo "New tag from create-release: ${{ needs.create-release.outputs.new-tag }}"
          fi

      - name: Configure deployment
        id: config
        uses: ./.github/actions/configure-deployment
        with:
          event-name: ${{ github.event_name }}
          ref: ${{ github.ref }}
          ref-name: ${{ github.ref_name }}
          git-tag: ${{ github.event.inputs.deployment_type == 'manual_tag_deploy' && github.event.inputs.tag_to_deploy || needs.create-release.outputs.new-tag }}
          manual-environment: production
          manual-target: ${{ github.event.inputs.deployment_type == 'manual_tag_deploy' && format('{0}/', github.event.inputs.deploy_target) || github.event.inputs.deploy_target }}
          deployment-context: ${{ github.event.inputs.deployment_type == 'manual_tag_deploy' && 'manual-tag' || 'release' }}
          base-path: ${{ secrets.DEPLOY_BASE_PATH }}

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest
    needs: [configure, create-release]
    if: always() && needs.configure.result == 'success'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.deployment_type == 'manual_tag_deploy' && github.event.inputs.tag_to_deploy || github.ref }}

      - name: Deploy website
        uses: ./.github/actions/deploy-website
        with:
          deployment-type: ${{ needs.configure.outputs.deployment-type }}
          target-path: ${{ needs.configure.outputs.target-path }}
          git-tag: ${{ needs.configure.outputs.git-tag }}
          build-artifact-name: 'build-files'
          sftp-host: ${{ secrets.SFTP_HOST }}
          sftp-username: ${{ secrets.SFTP_USERNAME }}
          sftp-password: ${{ secrets.SFTP_PASSWORD }}
          base-path: ${{ secrets.DEPLOY_BASE_PATH }}
