name: Release and Deploy

on:
  push:
    branches: [main]
    tags:
      - 'v*'
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment environment"
        required: true
        default: "production"
        type: choice
        options:
          - production
          - staging
      deploy_target:
        description: "Deployment target directory (relative to base path)"
        required: true
        default: "staging/"
        type: choice
        options:
          - "latest/"
          - "staging/"
      release_type:
        description: "Release type (only for main branch pushes)"
        required: false
        default: "none"
        type: choice
        options:
          - none
          - patch
          - minor
          - major

jobs:
  validate:
    name: Pre-build Validation
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm

      - name: Run linting
        run: pnpm run lint

      - name: Run type checking
        uses: ./.github/actions/typecheck

  build:
    name: Build Project
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js and pnpm
        uses: ./.github/actions/setup-node-pnpm

      - name: Build and verify
        uses: ./.github/actions/build-project

      - name: Verify build output exists
        run: |
          echo "Checking for build output..."
          if [ -d "out" ]; then
            echo "✅ out/ directory found"
            echo "Contents:"
            ls -la out/ | head -5
            echo "Total files: $(find out -type f | wc -l)"
          else
            echo "❌ out/ directory not found!"
            echo "Available directories:"
            ls -la
            exit 1
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-files
          path: out/
          retention-days: 1

  create-release:
    name: Create Release (if needed)
    runs-on: ubuntu-latest
    needs: build
    if: (github.event_name == 'pull_request' && github.event.pull_request.merged == true) || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main')
    outputs:
      new-tag: ${{ steps.release.outputs.new-tag }}
      should-create-release: ${{ steps.check.outputs.should-create-release }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check if release should be created
        id: check
        run: |
          SHOULD_CREATE="false"
          RELEASE_TYPE="none"
          
          # Check for release type in workflow input (manual dispatch)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.release_type }}" != "none" ]; then
            RELEASE_TYPE="${{ github.event.inputs.release_type }}"
            SHOULD_CREATE="true"
            echo "Manual release requested: $RELEASE_TYPE"
          # Check for release type in PR title and body (merged PR)
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
            PR_BODY="${{ github.event.pull_request.body }}"
            PR_TEXT="$PR_TITLE $PR_BODY"
            
            echo "Checking PR for release type..."
            echo "PR Title: $PR_TITLE"
            
            if echo "$PR_TEXT" | grep -qE "\[(major|minor|patch)\]"; then
              RELEASE_TYPE=$(echo "$PR_TEXT" | grep -oE "\[(major|minor|patch)\]" | head -1 | tr -d '[]')
              SHOULD_CREATE="true"
              echo "Release type found in PR text: $RELEASE_TYPE"
            elif echo "$PR_TEXT" | grep -qE "(#major|#minor|#patch)"; then
              RELEASE_TYPE=$(echo "$PR_TEXT" | grep -oE "#(major|minor|patch)" | head -1 | tr -d '#')
              SHOULD_CREATE="true"
              echo "Release type found in PR text: $RELEASE_TYPE"
            elif echo "$PR_TEXT" | grep -qiE "(major release|minor release|patch release)"; then
              if echo "$PR_TEXT" | grep -qiE "major release"; then
                RELEASE_TYPE="major"
              elif echo "$PR_TEXT" | grep -qiE "minor release"; then
                RELEASE_TYPE="minor"
              elif echo "$PR_TEXT" | grep -qiE "patch release"; then
                RELEASE_TYPE="patch"
              fi
              SHOULD_CREATE="true"
              echo "Release type found in PR text: $RELEASE_TYPE"
            else
              # Default to major release for merged PRs without explicit version type
              RELEASE_TYPE="major"
              SHOULD_CREATE="true"
              echo "No release type specified - defaulting to major release"
            fi
          fi
          
          echo "should-create-release=$SHOULD_CREATE" >> $GITHUB_OUTPUT
          echo "release-type=$RELEASE_TYPE" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: latest-tag
        if: steps.check.outputs.should-create-release == 'true'
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest-tag=$LATEST_TAG" >> $GITHUB_OUTPUT
          echo "Latest tag: $LATEST_TAG"

      - name: Calculate next version
        id: next-version
        if: steps.check.outputs.should-create-release == 'true'
        run: |
          LATEST_TAG="${{ steps.latest-tag.outputs.latest-tag }}"
          RELEASE_TYPE="${{ steps.check.outputs.release-type }}"
          
          # Remove 'v' prefix for calculation
          VERSION=${LATEST_TAG#v}
          
          # Split version into parts
          IFS='.' read -r -a VERSION_PARTS <<< "$VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}
          
          # Calculate new version based on release type
          case $RELEASE_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac
          
          NEW_VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "next-version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEW_VERSION"

      - name: Create and push tag
        id: release
        if: steps.check.outputs.should-create-release == 'true'
        run: |
          NEW_TAG="${{ steps.next-version.outputs.next-version }}"
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Create and push tag
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin "$NEW_TAG"
          
          echo "new-tag=$NEW_TAG" >> $GITHUB_OUTPUT
          echo "Created and pushed tag: $NEW_TAG"

  configure:
    name: Configure Deployment
    runs-on: ubuntu-latest
    needs: [build, create-release]
    if: always() && needs.build.result == 'success' && (needs.create-release.result == 'success' || needs.create-release.result == 'skipped')
    outputs:
      deployment-type: ${{ steps.config.outputs.deployment-type }}
      target-path: ${{ steps.config.outputs.target-path }}
      deployment-url: ${{ steps.config.outputs.deployment-url }}
      environment-name: ${{ steps.config.outputs.environment-name }}
      git-tag: ${{ steps.config.outputs.git-tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure deployment
        id: config
        uses: ./.github/actions/configure-deployment
        with:
          event-name: ${{ github.event_name }}
          ref: ${{ github.ref }}
          ref-name: ${{ github.ref_name }}
          git-tag: ${{ needs.create-release.outputs.new-tag }}
          manual-environment: ${{ github.event.inputs.environment }}
          manual-target: ${{ github.event.inputs.deploy_target }}
          deployment-context: 'release'
          base-path: ${{ secrets.DEPLOY_BASE_PATH }}

  deploy:
    name: Deploy to Server
    runs-on: ubuntu-latest  
    needs: [configure, create-release]
    if: always() && needs.configure.result == 'success'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Deploy website
        uses: ./.github/actions/deploy-website
        with:
          deployment-type: ${{ needs.configure.outputs.deployment-type }}
          target-path: ${{ needs.configure.outputs.target-path }}
          git-tag: ${{ needs.configure.outputs.git-tag }}
          build-artifact-name: 'build-files'
          sftp-host: ${{ secrets.SFTP_HOST }}
          sftp-username: ${{ secrets.SFTP_USERNAME }}
          sftp-password: ${{ secrets.SFTP_PASSWORD }}
          base-path: ${{ secrets.DEPLOY_BASE_PATH }}
